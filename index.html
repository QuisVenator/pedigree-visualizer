<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-i18n="app_title">HoF Pedigree App</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body { font-family: sans-serif; display: flex; height: 100vh; margin: 0; overflow: hidden; }
        
        /* Sidebar Styles */
        #sidebar { width: 300px; background: #f4f4f4; padding: 20px; border-right: 1px solid #ddd; display: flex; flex-direction: column; gap: 10px; }
        h2 { margin-top: 0; }
        .stat-box { background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        button { padding: 10px; cursor: pointer; background: #007bff; color: white; border: none; border-radius: 4px; font-size: 14px; }
        button:hover { background: #0056b3; }
        button.secondary { background: #6c757d; }
        button.remove { background: #dc3545; }
        
        /* Graph Styles */
        #graph-container { flex-grow: 1; position: relative; background: #fff; }
        .node path { fill: #fff; stroke: #333; stroke-width: 2px; cursor: pointer; transition: all 0.3s; }
        .node path:hover { fill: #e6f2ff; stroke: #007bff; }
        .node text { font: 12px sans-serif; pointer-events: none; text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, 0 -1px 0 #fff, -1px 0 0 #fff; }
        .link { fill: none; }
        .node.selected path {
            stroke: #ff4500;  /* Orange-Red for visibility */
            stroke-width: 4px;
            fill: #fff5ee;    /* Slight tint */
        }
        .node.hof.selected path {
            stroke: #ff4500; /* Selection overrides Gold border color */
            stroke-width: 5px;
            stroke-dasharray: 5, 2; /* Optional: dashed line to show it is special */
        }
        
        /* Hall of Fame Visuals */
        .node.hof path { stroke: #d4af37; stroke-width: 4px; fill: #fff8dc; } /* Gold */
        .node.hof text { font-weight: bold; fill: #8a6d1c; }
    </style>
</head>
<body>

<div id="sidebar">
    <h2>Horse Pedigree</h2>
    <div id="selected-horse-panel" class="stat-box" style="display:none;">
        <div style="display:flex; align-items:center; gap:10px;">
            <h3 id="panel-name" style="margin:0;">Pferd Name</h3>
            <button onclick="editName()" style="padding:2px 8px; font-size:12px; background:#6c757d;">‚úèÔ∏è</button>
        </div>
        <p><strong>HoF Status:</strong> <span id="panel-status">No</span></p>
        <p><strong>HoF Genetik:</strong> <span id="panel-score">0%</span></p>
        <hr>
        <button id="btn-toggle-hof">Hall of Fame umschalten</button>
        <div style="margin-top:10px; display:flex; gap:5px;">
            <button id="btn-add-sire" class="secondary">Vatertier Hinzuf√ºgen</button>
            <button id="btn-add-dam" class="secondary">Muttertier Hinzuf√ºgen</button>
        </div>
        <div style="margin-top:10px; display:flex; gap:5px;">
            <button id="btn-remove-sire" class="remove">Vatertier L√∂schen</button>
            <button id="btn-remove-dam" class="remove">Muttertier L√∂schen</button>
        </div>
        <hr>
        <hr>
        <div id="link-existing-panel" style="display:none; margin-top:10px;">
            
            <div style="margin-bottom:15px;">
                <label style="font-size:12px; font-weight:bold; color:#555;">Bekanntes Vatertier:</label>
                <div style="display:flex; gap:5px;">
                    <select id="existing-sire-select" style="flex-grow:1;"></select>
                    <button onclick="linkExisting('Sire')" style="background:#6f42c1; padding:5px 10px;">Link</button>
                </div>
            </div>

            <div>
                <label style="font-size:12px; font-weight:bold; color:#555;">Bekanntes Muttertier:</label>
                <div style="display:flex; gap:5px;">
                    <select id="existing-dam-select" style="flex-grow:1;"></select>
                    <button onclick="linkExisting('Dam')" style="background:#e83e8c; padding:5px 10px;">Link</button>
                </div>
            </div>

</div>
    </div>
    <div id="empty-state" class="stat-box">
        <p>Pferd ausw√§hlen um zu bearbeiten oder Eltern einzutragen.</p>
    </div>
    <hr>
    <h3>Daten</h3>
    <div style="display:flex; gap:5px; flex-direction:column;">
        <button onclick="exportData()" style="background:#28a745;">üíæ Kopie Speichern</button>
        <button onclick="document.getElementById('file-input').click()" style="background:#17a2b8;">üìÇ Daten Laden</button>
        <input type="file" id="file-input" style="display:none;" onchange="importData(this)">
    </div>
    <button onclick="resetData()" style="background:#dc3545; margin-top:5px;">üóëÔ∏è Zur√ºcksetzen</button>
</div>

<div id="graph-container"></div>

<script>
    let selectedHorseId = null;

    // --- 2. LOGIC / CALCULATIONS ---

    // Find horse helper
    const getHorse = (id) => horses.find(h => h.id === id);

    // The Recursive Percentage Calculator
    function calculateScore(id) {
        const horse = getHorse(id);
        if (!horse) return 0;

        if (horse.isHoF) return 100;

        const sireScore = calculateScore(horse.sireId);
        const damScore = calculateScore(horse.damId);

        return (sireScore / 2) + (damScore / 2);
    }

    // --- 3. D3 RENDERING ---

    const width = document.getElementById('graph-container').clientWidth;
    const height = document.getElementById('graph-container').clientHeight;
    
    // 1. SETUP SVG & LAYERS (Must happen once)
    const svg = d3.select("#graph-container").append("svg")
        .attr("width", width)
        .attr("height", height)
        .call(d3.zoom().on("zoom", (e) => mainGroup.attr("transform", e.transform)));
    
    const mainGroup = svg.append("g").attr("transform", "translate(50, 0)");

    // Define layers: Link layer first (bottom), Node layer second (top)
    const linkLayer = mainGroup.append("g").attr("class", "link-layer");
    const nodeLayer = mainGroup.append("g").attr("class", "node-layer");

    // 2. DEFINE VISUAL SCALES
    // Thickness: 0% = 1px, 100% = 8px
    const thicknessScale = d3.scaleSqrt().domain([0, 100]).range([1, 8]); 
    // Color: 0% = Light Gray, 100% = Gold
    const colorScale = d3.scaleSqrt().domain([0, 100]).range(["#cccccc", "#d4af37"]); 

    function renderTree() {
        // A. Build Data Hierarchy
        const buildHierarchy = (id) => {
            const h = getHorse(id);
            if (!h) return null;
            
            // Calculate score here so it's available for drawing
            const node = { ...h, score: calculateScore(id) };
            const children = [];
            
            const sire = buildHierarchy(h.sireId);
            const dam = buildHierarchy(h.damId);
            
            if (sire) children.push(sire);
            if (dam) children.push(dam);
            
            if (children.length) node.children = children;
            return node;
        };

        // Safety: If no horses exist, stop
        if (!horses || horses.length === 0) return;

        const rootData = buildHierarchy(horses[0].id);
        if (!rootData) return;

        // B. Calculate Layout
        const treeLayout = d3.tree().size([height - 100, width - 200]);
        const root = d3.hierarchy(rootData);
        treeLayout(root);

        // C. DRAW LINKS (Using Scales)
        const links = linkLayer.selectAll(".link")
            .data(root.links(), d => d.target.data.id);
        
        const linkEnter = links.enter().append("path")
            .attr("class", "link")
            .attr("fill", "none")
            // Start with current styles to prevent jumping
            .attr("stroke-width", d => thicknessScale(d.target.data.score))
            .attr("stroke", d => colorScale(d.target.data.score))
            .attr("d", d3.linkHorizontal()
                .x(d => d.y)
                .y(d => d.x)
            );

        // Update animation
        links.merge(linkEnter)
            .transition().duration(500)
            .attr("stroke-width", d => thicknessScale(d.target.data.score))
            .attr("stroke", d => colorScale(d.target.data.score))
            .attr("d", d3.linkHorizontal()
                .x(d => d.y)
                .y(d => d.x)
            );
            
        links.exit().remove();

        // D. DRAW NODES (Standard)
        const nodes = nodeLayer.selectAll(".node")
            .data(root.descendants(), d => d.data.id);

        const nodeEnter = nodes.enter().append("g")
            .attr("class", "node")
            .attr("transform", d => `translate(${d.y},${d.x})`)
            .on("click", (e, d) => selectHorse(d.data.id));

        // Define the shape generator
        // Size 700 is roughly equivalent to a radius 15 circle (Area = pi * r^2)
        const symbolGenerator = d3.symbol()
            .size(700) 
            .type(d => {
                if (d.data.sex === 'male') return d3.symbolSquare;
                return d3.symbolCircle;
            });

        // Append a 'path' element instead of a circle
        nodeEnter.append("path")
            .attr("d", symbolGenerator);
        
        nodeEnter.append("text")
            .attr("dy", -20)
            .attr("text-anchor", "middle")
            .text(d => d.data.name);

        nodeEnter.append("text")
            .attr("dy", 4)
            .attr("text-anchor", "middle")
            .style("font-size", "10px")
            .text(d => d.data.score + "%");

        const nodeUpdate = nodes.merge(nodeEnter);
        
        nodeUpdate.transition().duration(500)
            .attr("transform", d => `translate(${d.y},${d.x})`);

        // Apply Classes (HoF / Selected)
        nodeUpdate.attr("class", d => {
            let classes = "node";
            if (d.data.isHoF) classes += " hof";
            if (d.data.id === selectedHorseId) classes += " selected";
            return classes;
        });

        nodeUpdate.select("text").text(d => d.data.name);
        nodeUpdate.select("text:last-child").text(d => Number(d.data.score.toFixed(2)) + "%");

        nodes.exit().remove();
    }

    // --- 4. INTERACTION HANDLERS ---

    function selectHorse(id) {
        selectedHorseId = id;
        const horse = getHorse(id);
        const score = calculateScore(id);

        // Update UI
        document.getElementById("empty-state").style.display = "none";
        const panel = document.getElementById("selected-horse-panel");
        panel.style.display = "block";
        
        document.getElementById("panel-name").textContent = horse.name;
        document.getElementById("panel-status").textContent = horse.isHoF ? "Ja (100%)" : "Nein";
        document.getElementById("panel-score").textContent = score.toFixed(10) + "%";


        const sireSelect = document.getElementById("existing-sire-select");
        const damSelect = document.getElementById("existing-dam-select");
        
        sireSelect.innerHTML = "";
        damSelect.innerHTML = "";

        // 1. Get all potential parents (exclude self)
        const otherHorses = horses.filter(h => h.id !== id);
        otherHorses.sort((a, b) => a.name.localeCompare(b.name));

        // 2. Filter and Fill
        otherHorses.forEach(h => {
            const option = document.createElement("option");
            option.value = h.id;
            option.textContent = h.name;
            
            // Strict Filter: Only show Males in Sire list, Females in Dam list
            if (h.sex === 'male') {
                sireSelect.appendChild(option);
            } else {
                damSelect.appendChild(option);
            }
        });

        // Show the panel
        document.getElementById("link-existing-panel").style.display = "block";
        
        // Show/Hide Add Parent Buttons
        document.getElementById("btn-add-sire").style.display = horse.sireId ? "none" : "inline-block";
        document.getElementById("btn-add-dam").style.display = horse.damId ? "none" : "inline-block";
        document.getElementById("btn-remove-sire").style.display = horse.sireId ? "inline-block" : "none";
        document.getElementById("btn-remove-dam").style.display = horse.damId ? "inline-block" : "none";

        d3.selectAll(".node").classed("selected", false);
        d3.selectAll(".node")
            .filter(d => d.data.id === id)
            .classed("selected", true);
    }

    // Button: Toggle HoF
    document.getElementById("btn-toggle-hof").onclick = () => {
        if (!selectedHorseId) return;
        const horse = getHorse(selectedHorseId);
        horse.isHoF = !horse.isHoF;

        saveToLocal();

        renderTree();
        selectHorse(selectedHorseId);
    };

    // Button: Edit Name
    function editName() {
        if (!selectedHorseId) return;
        const horse = getHorse(selectedHorseId);

        const newName = prompt("Neuer Name f√ºr dieses Pferd:", horse.name);
        if (!newName || newName.trim() === "") return;
        
        horse.name = newName.trim();
        
        saveToLocal();
        renderTree();
        
        // We manually update the text here so we don't have to re-select the horse
        document.getElementById("panel-name").textContent = horse.name;
    }

    // Button: Add Parent (Vatertier/Muttertier)
    function addParent(type) {
        if (!selectedHorseId) return;
        const child = getHorse(selectedHorseId);
        
        const newSex = type === "Vatertier" ? "male" : "female";
        const newId = "h" + (Math.random() * 10000).toFixed(0);
        const newName = prompt(`Namen des ${type}:`, `${type} of ${child.name}`);
        
        if (!newName) return;

        const newHorse = {
            id: newId,
            name: newName,
            isHoF: false,
            sireId: null,
            damId: null,
            sex: newSex
        };
        
        horses.push(newHorse);

        if (type === "Vatertier") child.sireId = newId;
        else child.damId = newId;

        saveToLocal();

        renderTree();
        selectHorse(selectedHorseId);
    }

    // Button: Add existing
    function linkExisting(type) {
        if (!selectedHorseId) return;

        const child = getHorse(selectedHorseId);
        
        if (type === "Vatertier") {
            parentId = document.getElementById("existing-sire-select").value;
        } else {
            parentId = document.getElementById("existing-dam-select").value;
        }
        
        if (!parentId) {
            alert("Bitte ein " + type + " ausw√§hlen.");
            return;
        }

        if (checksForCycle(selectedHorseId, parentId)) {
            alert("Zeitreisende Pferde werden aktuell noch nicht unterst√ºtzt!\n(Die versuchte Verbindung w√ºrde ein Tier zu seinem eigenen Vorfahren machen)");
            return;
        }

        if (type === "Vatertier") {
            child.sireId = parentId;
        } else {
            child.damId = parentId;
        }

        // 3. Save and Refresh
        saveToLocal();
        renderTree(); // Re-draw the graph
        selectHorse(selectedHorseId); // Re-populate sidebar
    }

    function checksForCycle(childId, potentialParentId) {
        if (!potentialParentId) return false;
        if (childId === potentialParentId) return true;

        function isAncestor(currentId, targetId) {
            if (!currentId) return false;
            if (currentId === targetId) return true; // Time travel breedin detected!
            
            const current = getHorse(currentId);
            return isAncestor(current.sireId, targetId) || isAncestor(current.damId, targetId);
        }

        // We check: Is 'childId' already an ancestor of 'potentialParentId'?
        return isAncestor(potentialParentId, childId);
    }

    // Button: Remove Parent (Vatertier/Muttertier)
    function removeParent(type) {
        if (!selectedHorseId) return;
        const child = getHorse(selectedHorseId);
        
        if (type === "Vatertier") child.sireId = null;
        else child.damId = null;
        cleanupOrphans();

        saveToLocal();

        renderTree();
        selectHorse(selectedHorseId);
    }

    // --- GARBAGE COLLECTION ---
    function cleanupOrphans() {
        const activeIds = new Set();

        // 2. Recursive function to mark a horse and its ancestors as "Active"
        function markActive(id) {
            if (!id || activeIds.has(id)) return;
            
            activeIds.add(id);
            
            const horse = getHorse(id);
            if (horse) {
                markActive(horse.sireId);
                markActive(horse.damId);
            }
        }

        markActive("h1");

        const beforeCount = horses.length;
        horses = horses.filter(h => activeIds.has(h.id));
        
        const deletedCount = beforeCount - horses.length;
        if (deletedCount > 0) {
            console.log(`Deleted ${deletedCount} loose nodes.`);
        }
    }

    document.getElementById("btn-add-sire").onclick = () => addParent("Vatertier");
    document.getElementById("btn-add-dam").onclick = () => addParent("Muttertier");
    document.getElementById("btn-remove-sire").onclick = () => removeParent("Vatertier");
    document.getElementById("btn-remove-dam").onclick = () => removeParent("Muttertier");

    
    // --- 5. DATA PERSISTENCE (IMPORT/EXPORT) ---

    // EXPORT: Downloads the current 'horses' array as a .json file
    function exportData() {
        const dataStr = JSON.stringify(horses, null, 2); // Pretty print JSON
        const blob = new Blob([dataStr], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        
        // Create a fake link and click it to trigger download
        const a = document.createElement("a");
        a.href = url;
        a.download = "horse_pedigree_data.json";
        document.body.appendChild(a);
        a.click();
        
        // Cleanup
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    // IMPORT: Reads a user-selected file and replaces 'horses' array
    function importData(inputElement) {
        const file = inputElement.files[0];
        if (!file) return;

        const reader = new FileReader();
        
        reader.onload = function(e) {
            try {
                const json = JSON.parse(e.target.result);
                
                // Basic validation: check if it looks like an array
                if (Array.isArray(json)) {
                    horses = json;
                    selectedHorseId = null;
                    
                    document.getElementById("selected-horse-panel").style.display = "none";
                    document.getElementById("empty-state").style.display = "block";

                    saveToLocal();
                    
                    renderTree(); 
                    alert("Daten wurden erfolgreich importiert!");
                } else {
                    alert("Fehler: Falsches Format");
                }
            } catch (err) {
                alert("Fehler beim Lesen der Datei: " + err);
            }
        };
        
        reader.readAsText(file);
        // Reset input so you can load the same file again if needed
        inputElement.value = ""; 
    }

    // --- LOCAL STORAGE HELPERS ---

    const STORAGE_KEY = "horse_app_data_v1";

    function saveToLocal() {
        // Convert the array to a string and save it
        localStorage.setItem(STORAGE_KEY, JSON.stringify(horses));
        console.log("Data auto-saved!"); 
    }

    function loadFromLocal() {
        const savedData = localStorage.getItem(STORAGE_KEY);
        if (savedData) {
            return JSON.parse(savedData);
        }
        return null;
    }

    function resetData() {
        if (confirm("Sind Sie sicher? Dies l√∂scht alle Daten und startet einen neuen Stammbaum.")) {
            localStorage.removeItem(STORAGE_KEY); // Delete the save file
            location.reload(); // Reload the page to reset the app
        }
    }

    function createRootHorse() {
        // 1. Ask for Name
        let name = prompt("Willkomen! Bitte Named des analysierten Pferdes angeben:");
        if (!name || name.trim() === "") {
            name = "Mein Pferd"; // Fallback so the app doesn't break
        }

        // 2. Ask for Gender
        // confirm() returns TRUE for OK (Male) and FALSE for Cancel (Female)
        const isMale = confirm(`Ist "${name}" ein Hengst?\n\nOK f√ºr Hengs.\nCancel f√ºr Stute.`);
        const sex = isMale ? 'male' : 'female';

        // 3. Create the Root Object
        const rootHorse = {
            id: "h1",
            name: name,
            isHoF: false,
            sireId: null,
            damId: null,
            sex: sex
        };

        // 4. Save and Start
        horses = [rootHorse];
        saveToLocal();
        renderTree();
    }

    // --- Start! ---

    // Initial Data: Just one horse to start
    let horses = loadFromLocal()
    if (!horses || horses.length === 0) {
        createRootHorse();
    } else {
        renderTree();
    }

</script>
</body>
</html>